"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const buffer_1 = require("buffer");
const stream_1 = require("stream");
const mock_fs_1 = __importDefault(require("mock-fs"));
const func_core_tools_1 = require("./func-core-tools");
jest.mock("process", () => ({ versions: { node: "16.0.0" } }));
jest.mock("os", () => ({ platform: () => "linux", homedir: () => "/home/user" }));
jest.mock("child_process", () => ({ exec: jest.fn() }));
jest.mock("node-fetch", () => jest.fn());
jest.mock("unzipper", () => ({
    Extract: () => {
        const fakeStream = new stream_1.PassThrough();
        fakeStream.promise = () => Promise.resolve();
        mock_fs_1.default({
            "/home/user/.swa/core-tools/v4/func": "",
            "/home/user/.swa/core-tools/v4/gozip": "",
        }, { createTmp: false, createCwd: false });
        return fakeStream;
    },
}));
describe("funcCoreTools", () => {
    afterEach(() => {
        mock_fs_1.default.restore();
    });
    describe("isCoreToolsVersionCompatible()", () => {
        it("should return true for compatible versions", () => {
            expect(func_core_tools_1.isCoreToolsVersionCompatible(4, 10)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(3, 10)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(2, 10)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(3, 11)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(2, 11)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(4, 12)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(3, 12)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(2, 12)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(3, 13)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(4, 14)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(3, 14)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(2, 14)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(4, 15)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(3, 15)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(4, 16)).toBe(true);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(3, 16)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(2, 16)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(4, 17)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(3, 17)).toBe(false);
            expect(func_core_tools_1.isCoreToolsVersionCompatible(2, 17)).toBe(false);
        });
    });
    describe("detectTargetCoreToolsVersion()", () => {
        it("should return the latest valid version for each Node version", () => {
            expect(func_core_tools_1.detectTargetCoreToolsVersion(8)).toBe(2);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(9)).toBe(2);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(10)).toBe(3);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(11)).toBe(3);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(12)).toBe(3);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(13)).toBe(3);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(14)).toBe(4);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(15)).toBe(4);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(16)).toBe(4);
            // Unsupported Node versions should always return the latest version
            expect(func_core_tools_1.detectTargetCoreToolsVersion(7)).toBe(4);
            expect(func_core_tools_1.detectTargetCoreToolsVersion(17)).toBe(4);
        });
    });
    describe("getLatestCoreToolsRelease()", () => {
        it("should return the latest release for the specified version", async () => {
            const fetchMock = jest.requireMock("node-fetch");
            fetchMock.mockImplementationOnce(() => Promise.resolve({
                json: () => Promise.resolve({
                    tags: {
                        v4: {
                            release: "4.0.0",
                        },
                    },
                    releases: {
                        "4.0.0": {
                            coreTools: [
                                {
                                    OS: "Linux",
                                    downloadLink: "https://abc.com/d.zip",
                                    sha2: "123",
                                    size: "full",
                                },
                            ],
                        },
                    },
                }),
            }));
            const release = await func_core_tools_1.getLatestCoreToolsRelease(4);
            expect(release.version).toBe("4.0.0");
            expect(release.sha2).toBe("123");
        });
        it("should throw an error if tags match the specified version", async () => {
            const fetchMock = jest.requireMock("node-fetch");
            fetchMock.mockImplementationOnce(() => Promise.resolve({
                json: () => Promise.resolve({
                    tags: {
                        v3: {},
                        v4: { hidden: true },
                    },
                }),
            }));
            await expect(async () => await func_core_tools_1.getLatestCoreToolsRelease(4)).rejects.toThrowError("Cannot find the latest version for v4");
        });
        it("should throw an error if no release match the specified version", async () => {
            const fetchMock = jest.requireMock("node-fetch");
            fetchMock.mockImplementationOnce(() => Promise.resolve({
                json: () => Promise.resolve({
                    tags: {
                        v4: { release: "4.0.0" },
                    },
                    releases: {},
                }),
            }));
            await expect(async () => await func_core_tools_1.getLatestCoreToolsRelease(4)).rejects.toThrowError("Cannot find release for 4.0.0");
        });
        it("should throw an error if there's no compatible package", async () => {
            const fetchMock = jest.requireMock("node-fetch");
            fetchMock.mockImplementationOnce(() => Promise.resolve({
                json: () => Promise.resolve({
                    tags: {
                        v4: { release: "4.0.0" },
                    },
                    releases: {
                        "4.0.0": {
                            coreTools: [
                                {
                                    OS: "Windows",
                                    downloadLink: "https://abc.com/d.zip",
                                    sha2: "123",
                                    size: "full",
                                },
                            ],
                        },
                    },
                }),
            }));
            await expect(async () => await func_core_tools_1.getLatestCoreToolsRelease(4)).rejects.toThrowError("Cannot find download package for Linux");
        });
        it("should throw an error if no release match the specified version", async () => {
            const fetchMock = jest.requireMock("node-fetch");
            fetchMock.mockImplementationOnce(() => Promise.reject(new Error("bad network")));
            await expect(async () => await func_core_tools_1.getLatestCoreToolsRelease(4)).rejects.toThrowError(/bad network/);
        });
    });
    describe("getCoreToolsBinary", () => {
        it("should return the system binary if it's compatible", async () => {
            const execMock = jest.requireMock("child_process").exec;
            execMock.mockImplementationOnce((_cmd, cb) => cb(null, { stdout: "4.0.0" }));
            const binary = await func_core_tools_1.getCoreToolsBinary();
            expect(binary).toBe("func");
        });
        it("should return the downloaded binary if there's no system binary", async () => {
            const execMock = jest.requireMock("child_process").exec;
            execMock.mockImplementationOnce((_cmd, cb) => cb({ stderr: "func does not exist" }));
            mock_fs_1.default({
                ["/home/user/.swa/core-tools/v4"]: { ".release-version": "4.3.2" },
            }, { createTmp: false, createCwd: false });
            const binary = await func_core_tools_1.getCoreToolsBinary();
            // note: we have mocked os.platform(), so we can't check for os name!
            if (path_1.sep === "/") {
                expect(binary).toBe("/home/user/.swa/core-tools/v4/func");
            }
            else {
                expect(binary).toContain(":\\home\\user\\.swa\\core-tools\\v4\\func");
            }
        });
        it("should return the downloaded binary if the system binary is incompatible", async () => {
            const execMock = jest.requireMock("child_process").exec;
            execMock.mockImplementationOnce((_cmd, cb) => cb(null, { stdout: "3.0.0" }));
            mock_fs_1.default({
                ["/home/user/.swa/core-tools/v4"]: { ".release-version": "4.3.2" },
            }, { createTmp: false, createCwd: false });
            const binary = await func_core_tools_1.getCoreToolsBinary();
            // note: we have mocked os.platform(), so we can't check for os name!
            if (path_1.sep === "/") {
                expect(binary).toBe("/home/user/.swa/core-tools/v4/func");
            }
            else {
                expect(binary).toContain(":\\home\\user\\.swa\\core-tools\\v4\\func");
            }
        });
        it("should download core tools and return downloaded binary", async () => {
            const execMock = jest.requireMock("child_process").exec;
            execMock.mockImplementationOnce((_cmd, cb) => cb({ stderr: "func does not exist" }));
            const fetchMock = jest.requireMock("node-fetch");
            fetchMock.mockImplementationOnce(() => Promise.resolve({
                json: () => Promise.resolve({
                    tags: {
                        v4: { release: "4.0.0" },
                    },
                    releases: {
                        "4.0.0": {
                            coreTools: [
                                {
                                    OS: "Linux",
                                    downloadLink: "https://abc.com/d.zip",
                                    // Real sha2 for "package" string
                                    sha2: "bc4a71180870f7945155fbb02f4b0a2e3faa2a62d6d31b7039013055ed19869a",
                                    size: "full",
                                },
                            ],
                        },
                    },
                }),
            }));
            const packageZip = buffer_1.Buffer.from("package");
            fetchMock.mockImplementationOnce(() => Promise.resolve({
                body: stream_1.Readable.from(packageZip),
                headers: new Headers({ "content-length": packageZip.length.toString() }),
            }));
            mock_fs_1.default({ ["/home/user/.swa/core-tools/"]: {} }, { createTmp: false, createCwd: false });
            const binary = await func_core_tools_1.getCoreToolsBinary();
            // note: we have mocked os.platform(), so we can't check for os name!
            if (path_1.sep === "/") {
                expect(binary).toBe("/home/user/.swa/core-tools/v4/func");
            }
            else {
                expect(binary).toContain(":\\home\\user\\.swa\\core-tools\\v4\\func");
            }
        });
        it("should return undefined if an error occured", async () => {
            const execMock = jest.requireMock("child_process").exec;
            execMock.mockImplementationOnce((_cmd, cb) => cb({ stderr: "func does not exist" }));
            const fetchMock = jest.requireMock("node-fetch");
            fetchMock.mockImplementationOnce(() => Promise.reject({}));
            mock_fs_1.default({}, { createTmp: false, createCwd: false });
            const binary = await func_core_tools_1.getCoreToolsBinary();
            expect(binary).toBe(undefined);
        });
    });
    describe("downloadCoreTools", () => {
        it("should throw an error if the download is corrupted", async () => {
            const execMock = jest.requireMock("child_process").exec;
            execMock.mockImplementationOnce((_cmd, cb) => cb({ stderr: "func does not exist" }));
            const fetchMock = jest.requireMock("node-fetch");
            fetchMock.mockImplementationOnce(() => Promise.resolve({
                json: () => Promise.resolve({
                    tags: {
                        v4: { release: "4.0.0" },
                    },
                    releases: {
                        "4.0.0": {
                            coreTools: [
                                {
                                    OS: "Linux",
                                    downloadLink: "https://abc.com/d.zip",
                                    sha2: "123",
                                    size: "full",
                                },
                            ],
                        },
                    },
                }),
            }));
            const packageZip = buffer_1.Buffer.from("package");
            fetchMock.mockImplementationOnce(() => Promise.resolve({
                body: stream_1.Readable.from(packageZip),
                headers: new Headers({ "content-length": packageZip.length.toString() }),
            }));
            mock_fs_1.default({ ["/home/user/.swa/core-tools/"]: {} }, { createTmp: false, createCwd: false });
            await expect(async () => await func_core_tools_1.downloadCoreTools(4)).rejects.toThrowError(/SHA2 mismatch/);
        });
    });
});
//# sourceMappingURL=func-core-tools.spec.js.map