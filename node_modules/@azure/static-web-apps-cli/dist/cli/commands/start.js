"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const concurrently_1 = __importDefault(require("concurrently"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const config_1 = require("../../config");
const core_1 = require("../../core");
const builder_1 = __importDefault(require("../../core/builder"));
let packageInfo = require("../../../package.json");
async function start(startContext, options) {
    // WARNING:
    // environment variables are populated using values provided by the user to the CLI.
    // Code below doesn't have access to these environment variables which are defined later below.
    // Make sure this code (or code from utils) does't depend on environment variables!
    var _a, _b, _c, _d, _e, _f;
    let useAppDevServer = undefined;
    let useApiDevServer = undefined;
    let startupCommand = undefined;
    // make sure the CLI default port is available before proceeding.
    if (await core_1.isAcceptingTcpConnections({ host: options.host, port: options.port })) {
        core_1.logger.error(`Port ${options.port} is already used. Choose a different port.`, true);
    }
    if (core_1.isHttpUrl(startContext)) {
        useAppDevServer = startContext;
        options.outputLocation = useAppDevServer;
    }
    else {
        let outputLocationRelative = path_1.default.resolve(options.appLocation, startContext);
        // start the emulator from a specific artifact folder relative to appLocation, if folder exists
        if (fs_1.default.existsSync(outputLocationRelative)) {
            options.outputLocation = outputLocationRelative;
        }
        //check for artifact folder using the absolute location
        else if (fs_1.default.existsSync(startContext)) {
            options.outputLocation = startContext;
        }
        else {
            // prettier-ignore
            core_1.logger.error(`The dist folder "${outputLocationRelative}" is not found.\n` +
                `Make sure that this folder exists or use the --build option to pre-build the static app.`, true);
        }
    }
    if (options.apiLocation) {
        if (core_1.isHttpUrl(options.apiLocation)) {
            useApiDevServer = options.apiLocation;
            options.apiLocation = useApiDevServer;
        }
        // make sure api folder exists
        else if (fs_1.default.existsSync(options.apiLocation) === false) {
            core_1.logger.info(`Skipping API because folder "${options.apiLocation}" is missing`);
        }
    }
    // get the app and api artifact locations
    let [appLocation, outputLocation, apiLocation] = [options.appLocation, options.outputLocation, options.apiLocation];
    let apiPort = (options.apiPort || config_1.DEFAULT_CONFIG.apiPort);
    let devserverTimeout = (options.devserverTimeout || config_1.DEFAULT_CONFIG.devserverTimeout);
    let userWorkflowConfig = {
        appLocation,
        outputLocation,
        apiLocation,
    };
    // mix CLI args with the project's build workflow configuration (if any)
    // use any specific workflow config that the user might provide undef ".github/workflows/"
    // Note: CLI args will take precedence over workflow config
    try {
        userWorkflowConfig = core_1.readWorkflowFile({
            userWorkflowConfig,
        });
    }
    catch (err) {
        core_1.logger.warn(``, "swa");
        core_1.logger.warn(`Error reading workflow configuration:`, "swa");
        core_1.logger.warn(err.message, "swa");
        core_1.logger.warn(`See https://docs.microsoft.com/azure/static-web-apps/build-configuration?tabs=github-actions#build-configuration for more information.`, "swa");
    }
    const isApiLocationExistsOnDisk = fs_1.default.existsSync(userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation);
    // handle the API location config
    let serveApiCommand = "echo 'No API found. Skipping'";
    if (useApiDevServer) {
        serveApiCommand = `echo 'using API dev server at ${useApiDevServer}'`;
        // get the API port from the dev server
        apiPort = (_a = core_1.parseUrl(useApiDevServer)) === null || _a === void 0 ? void 0 : _a.port;
    }
    else {
        if (options.apiLocation && (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation)) {
            // check if the func binary is globally available and if not, download it
            const funcBinary = await core_1.getCoreToolsBinary();
            const nodeMajorVersion = core_1.getNodeMajorVersion();
            const targetVersion = core_1.detectTargetCoreToolsVersion(nodeMajorVersion);
            if (!funcBinary) {
                // prettier-ignore
                core_1.logger.error(`\nCould not find or install Azure Functions Core Tools.\n` +
                    `Install Azure Functions Core Tools with:\n\n` +
                    `  npm i -g azure-functions-core-tools@${targetVersion} --unsafe-perm true\n\n` +
                    `See https://aka.ms/functions-core-tools for more information.`, true);
            }
            else {
                if (core_1.isCoreToolsVersionCompatible(targetVersion, nodeMajorVersion) === false) {
                    core_1.logger.error(`Found Azure Functions Core Tools v${targetVersion} which is incompatible with your current Node.js v${process.versions.node}.`);
                    core_1.logger.error("See https://aka.ms/functions-node-versions for more information.");
                    process.exit(1);
                }
                // serve the api if and only if the user provides a folder via the --api-location flag
                if (isApiLocationExistsOnDisk) {
                    serveApiCommand = `cd "${userWorkflowConfig.apiLocation}" && ${funcBinary} start --cors "*" --port ${options.apiPort} ${(_b = options.funcArgs) !== null && _b !== void 0 ? _b : ""}`;
                }
            }
        }
    }
    if (options.ssl) {
        if (options.sslCert === undefined || options.sslKey === undefined) {
            core_1.logger.error(`SSL Key and SSL Cert are required when using HTTPS`, true);
        }
    }
    if (options.run) {
        startupCommand = core_1.createStartupScriptCommand(options.run, options);
    }
    // WARNING: code from above doesn't have access to env vars which are only defined below
    // set env vars for current command
    const envVarsObj = {
        SWA_CLI_DEBUG: options.verbose,
        SWA_CLI_API_PORT: `${apiPort}`,
        SWA_CLI_APP_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation,
        SWA_CLI_OUTPUT_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.outputLocation,
        SWA_CLI_API_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation,
        SWA_CLI_ROUTES_LOCATION: options.swaConfigLocation,
        SWA_CLI_HOST: options.host,
        SWA_CLI_PORT: `${options.port}`,
        SWA_WORKFLOW_FILES: (_c = userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.files) === null || _c === void 0 ? void 0 : _c.join(","),
        SWA_CLI_APP_SSL: `${options.ssl}`,
        SWA_CLI_APP_SSL_CERT: options.sslCert,
        SWA_CLI_APP_SSL_KEY: options.sslKey,
        SWA_CLI_STARTUP_COMMAND: startupCommand,
        SWA_CLI_VERSION: packageInfo.version,
        SWA_CLI_DEVSERVER_TIMEOUT: `${devserverTimeout}`,
        SWA_CLI_OPEN: `${options.open}`,
    };
    // merge SWA env variables with process.env
    process.env = { ...process.env, ...envVarsObj };
    // INFO: from here code may access SWA CLI env vars.
    const { env } = process;
    const concurrentlyCommands = [
        // start the reverse proxy
        { command: `node "${path_1.default.join(__dirname, "..", "..", "msha", "server.js")}"`, name: "swa", env, prefixColor: "gray.dim" },
    ];
    if (isApiLocationExistsOnDisk) {
        concurrentlyCommands.push(
        // serve the api, if it's available
        { command: serveApiCommand, name: "api", env, prefixColor: "gray.dim" });
    }
    if (startupCommand) {
        concurrentlyCommands.push(
        // run an external script, if it's available
        { command: `cd "${userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation}" && ${startupCommand}`, name: "run", env, prefixColor: "gray.dim" });
    }
    if (options.build) {
        // run the app/api builds
        await builder_1.default({
            config: userWorkflowConfig,
        });
    }
    core_1.logger.silly({
        ssl: [options.ssl, options.sslCert, options.sslKey],
        env: envVarsObj,
        commands: {
            swa: (_d = concurrentlyCommands.find((c) => c.name === "swa")) === null || _d === void 0 ? void 0 : _d.command,
            api: (_e = concurrentlyCommands.find((c) => c.name === "api")) === null || _e === void 0 ? void 0 : _e.command,
            run: (_f = concurrentlyCommands.find((c) => c.name === "run")) === null || _f === void 0 ? void 0 : _f.command,
        },
    }, "swa");
    const { result } = concurrently_1.default(concurrentlyCommands, { restartTries: 0 });
    await result.then(() => process.exit(), () => process.exit());
}
exports.start = start;
//# sourceMappingURL=start.js.map